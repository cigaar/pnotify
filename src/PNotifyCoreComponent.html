<!--
 ====== PNotify ======

 http://sciactive.com/pnotify/

 Copyright 2009-2019 Hunter Perrin
 Copyright 2015 Google, Inc.

 Licensed under Apache License, Version 2.0.
  http://www.apache.org/licenses/LICENSE-2.0
-->

<svelte:options accessors={true} />

<script context="module">
  export const VERSION = '4.0.0';

  let posTimer; // Position all timer.

  // These actions need to be done once the DOM is ready.
  function onDocumentLoaded () {
    defaultStack.context = document.body;
    // Reposition the notices when the window resizes.
    window.addEventListener('resize', () => {
      if (posTimer) {
        clearTimeout(posTimer);
      }
      posTimer = setTimeout(() => {
        positionAll();
      }, 10);
    });
  }

  // Creates the background overlay for modal stacks.
  function createStackOverlay (stack) {
    const overlay = document.createElement('div');
    overlay.classList.add('ui-pnotify-modal-overlay');
    if (stack.context !== document.body) {
      overlay.style.height = stack.context.scrollHeight + 'px';
      overlay.style.width = stack.context.scrollWidth + 'px';
    }
    // Close the notices on overlay click.
    overlay.addEventListener('click', () => {
      if (stack.overlayClose) {
        closeStack(stack);
      }
    });
    stack.overlay = overlay;
  }

  function insertStackOverlay (stack) {
    if (stack.overlay.parentNode !== stack.context) {
      stack.overlay = stack.context.insertBefore(stack.overlay, stack.context.firstChild);
    }
  }

  function removeStackOverlay (stack) {
    if (stack.overlay.parentNode) {
      stack.overlay.parentNode.removeChild(stack.overlay);
    }
  }

  export const defaultStack = {
    dir1: 'down',
    dir2: 'left',
    firstpos1: 25,
    firstpos2: 25,
    spacing1: 36,
    spacing2: 36,
    push: 'bottom',
    context: window && document.body
  };

  export const defaults = {
    // The notice's title.
    title: false,
    // Whether to trust the title or escape its contents. (Not allow HTML.)
    titleTrusted: false,
    // The notice's text.
    text: false,
    // Whether to trust the text or escape its contents. (Not allow HTML.)
    textTrusted: false,
    // What styling classes to use. (Can be 'brighttheme', 'material', 'bootstrap3', 'bootstrap4', or a styling object.)
    styling: 'brighttheme',
    // What icons to use (Can be 'brighttheme', 'material', 'bootstrap3', 'fontawesome4', 'fontawesome5', or an icon object.)
    icons: 'brighttheme',
    // Additional classes to be added to the notice. (For custom styling.)
    addClass: '',
    // Class to be added to the notice for corner styling.
    cornerClass: '',
    // Display the notice when it is created.
    autoDisplay: true,
    // Width of the notice.
    width: '360px',
    // Minimum height of the notice. It will expand to fit content.
    minHeight: '16px',
    // Type of the notice. 'notice', 'info', 'success', or 'error'.
    type: 'notice',
    // Set icon to true to use the default icon for the selected
    // style/type, false for no icon, or a string for your own icon class.
    icon: true,
    // The animation to use when displaying and hiding the notice. 'none'
    // and 'fade' are supported through CSS. Others are supported
    // through the Animate module and Animate.css.
    animation: 'fade',
    // Speed at which the notice animates in and out. 'slow', 'normal',
    // or 'fast'. Respectively, 400ms, 250ms, 100ms.
    animateSpeed: 'normal',
    // Display a drop shadow.
    shadow: true,
    // After a delay, remove the notice.
    hide: true,
    // Delay in milliseconds before the notice is removed.
    delay: 8000,
    // Reset the hide timer if the mouse moves over the notice.
    mouseReset: true,
    // Remove the notice's elements from the DOM after it is removed.
    remove: true,
    // Whether to remove the notice from the global array when it is closed.
    destroy: true,
    // The stack on which the notices will be placed. Also controls the
    // direction the notices stack.
    stack: defaultStack,
    // This is where options for modules should be defined.
    modules: {}
  };

  // An array of all active notices.
  export const notices = [];

  // This object holds all the PNotify modules. They are used to provide
  // additional functionality.
  const moduleRegistry = {};
  export { moduleRegistry as modules };

  // Modules can add themselves to these to be rendered in the template.
  export const modulesPrependContainer = [];
  export const modulesAppendContainer = [];

  // Close all notices.
  export function closeAll () {
    for (let i = 0; i < notices.length; i++) {
      if (notices[i].close) {
        notices[i].close(false);
      }
    }
  }

  // Close all notices in a single stack.
  export function closeStack (stack) {
    if (stack === false) {
      return;
    }
    for (let i = 0; i < notices.length; i++) {
      if (notices[i].close && notices[i].stack === stack) {
        notices[i].close(false);
      }
    }
  }

  // Position all notices.
  export function positionAll () {
    // This timer is used for queueing this function so it doesn't run
    // repeatedly.
    if (posTimer) {
      clearTimeout(posTimer);
    }
    posTimer = null;
    // Reset the next position data.
    if (notices.length > 0) {
      for (let i = 0; i < notices.length; i++) {
        let notice = notices[i];
        let stack = notice.stack;
        if (!stack) {
          continue;
        }
        if (stack.overlay) {
          removeStackOverlay(stack);
        }
        stack.nextpos1 = stack.firstpos1;
        stack.nextpos2 = stack.firstpos2;
        stack.addpos2 = 0;
      }
      for (let i = 0; i < notices.length; i++) {
        notices[i].position();
      }
    } else {
      delete defaultStack.nextpos1;
      delete defaultStack.nextpos2;
    }
  }

  const styleRegistry = {
    bootstrap3: {
      container: 'alert',
      notice: 'alert-warning',
      info: 'alert-info',
      success: 'alert-success',
      error: 'alert-danger'
    },
    bootstrap4: {
      container: 'alert',
      notice: 'alert-warning',
      info: 'alert-info',
      success: 'alert-success',
      error: 'alert-danger'
    }
  };
  export { styleRegistry as styles };

  // icons are separate from the style, since bs4 doesn't come with any
  const iconRegistry = {
    bootstrap3: {
      notice: 'glyphicon glyphicon-exclamation-sign',
      info: 'glyphicon glyphicon-info-sign',
      success: 'glyphicon glyphicon-ok-sign',
      error: 'glyphicon glyphicon-warning-sign'
    },
    // User must have Font Awesome v4.0+
    fontawesome4: {
      notice: 'fa fa-exclamation-circle',
      info: 'fa fa-info-circle',
      success: 'fa fa-check-circle',
      error: 'fa fa-exclamation-triangle'
    },
    // User must have Font Awesome v5.0+
    fontawesome5: {
      notice: 'fas fa-exclamation-circle',
      info: 'fas fa-info-circle',
      success: 'fas fa-check-circle',
      error: 'fas fa-exclamation-triangle'
    }
  };
  export { iconRegistry as icons };

  // Run the deferred actions once the DOM is ready.
  if (window && document.body) {
    onDocumentLoaded();
  } else {
    document.addEventListener('DOMContentLoaded', onDocumentLoaded);
  }
</script>

<div bind:this={refs.elem}
    class="
      ui-pnotify
      {icon !== false ? 'ui-pnotify-with-icon' : ''}
      {getStyle('element')}
      {addClass}
      {_animatingClass}
      {_moveClass}
      {animation === 'fade' ? 'ui-pnotify-fade-'+animateSpeed : ''}
      {stack && stack.modal ? 'ui-pnotify-modal' : ''}
      {_moduleClasses.elem.join(' ')}
    "
    aria-live="assertive"
    role="alertdialog"
    ui-pnotify
    on:mouseover
    on:mouseout
    on:mouseenter={mouseenter}
    on:mouseleave={mouseleave}
    on:mousemove
    on:mousedown
    on:mouseup
    on:click
    on:dblclick
    on:focus
    on:blur
    on:touchstart
    on:touchmove
    on:touchend
    on:touchcancel
    on:animationend
    on:transitionend>
  <div bind:this={refs.container}
      class="
        ui-pnotify-container
        {getStyle('container')}
        {getStyle(type)}
        {cornerClass}
        {shadow ? 'ui-pnotify-shadow' : ''}
        {_moduleClasses.container.join(' ')}
      "
      style="{_widthStyle} {_minHeightStyle}"
      role="alert">
    {#if self}
      {#each modulesPrependContainer as module (module.key)}
        <!-- <svelte:component this={module} bind:this={_modulesPrependContainerInstances[module.key]} on:init={() => initModule(_modulesPrependContainerInstances[index])} /> -->
        <svelte:component this={module} on:init={event => saveAccessor(module.key, event.detail)} _notice={self} {...modules[module.key]} />
      {/each}
    {/if}
    {#if icon !== false}
      <div bind:this={refs.iconContainer} class="ui-pnotify-icon {getStyle('icon')}">
        <span class={icon === true ? getIcon(type) : icon}></span>
      </div>
    {/if}
    {#if title !== false}
      <h4 bind:this={refs.titleContainer} class="ui-pnotify-title {getStyle('title')}">
        {#if titleTrusted}
          {@html title}
        {:else}
          {title}
        {/if}
      </h4>
    {/if}
    {#if text !== false}
      <div bind:this={refs.textContainer} class="ui-pnotify-text {getStyle('text')}" role="alert">
        {#if textTrusted}
          {@html text}
        {:else}
          {text}
        {/if}
      </div>
    {/if}
    {#if self}
      {#each modulesAppendContainer as module (module.key)}
        <svelte:component this={module} on:init={event => saveAccessor(module.key, event.detail)} _notice={self} {...modules[module.key]} />
      {/each}
    {/if}
  </div>
</div>

<script>
  import { onMount, beforeUpdate, tick, createEventDispatcher } from 'svelte';

  let self;
  const dispatch = createEventDispatcher();

  export let title = defaults.title;
  export let titleTrusted = defaults.titleTrusted;
  export let text = defaults.text;
  export let textTrusted = defaults.textTrusted;
  export let styling = defaults.styling;
  export let icons = defaults.icons;
  export let addClass = defaults.addClass;
  export let cornerClass = defaults.cornerClass;
  export let autoDisplay = defaults.autoDisplay;
  export let width = defaults.width;
  export let minHeight = defaults.minHeight;
  export let type = defaults.type;
  export let icon = defaults.icon;
  export let animation = defaults.animation;
  export let animateSpeed = defaults.animateSpeed;
  export let shadow = defaults.shadow;
  export let hide = defaults.hide;
  export let delay = defaults.delay;
  export let mouseReset = defaults.mouseReset;
  export let remove = defaults.remove;
  export let destroy = defaults.destroy;
  export let stack = defaults.stack;
  export let modules = Object.assign({}, defaults.modules);

  export const refs = {
    elem: null,
    container: null,
    iconContainer: null,
    titleContainer: null,
    textContainer: null
  };

  // The state can be 'initializing', 'opening', 'open', 'closing', and 'closed'.
  let _state = 'initializing';
  // Auto close timer.
  let _timer = null;
  // Animation timer.
  let _animTimer = null;
  // Stores what is currently being animated (in or out).
  let _animating = false;
  // Stores the class that adds entry/exit animation effects.
  let _animatingClass = '';
  // Stores the class that adds movement animation effects.
  let _moveClass = '';
  // Stores whether the notice was hidden by a timer.
  let _timerHide = false;
  // Stores the accessors of the modules.
  let _moduleAccessors = {};
  // Holds classes that modules add for the notice element or container element.
  let _moduleClasses = {
    elem: [],
    container: []
  };
  // Modules that change how the notice displays (causing the notice element to not appear) can set this to true to make PNotify assume the notice has opened.
  let _moduleIsNoticeOpen = false;

  // These hold the instances to the Svelte-loaded modules.
  // const _modulesPrependContainerInstances = [];
  // const _modulesAppendContainerInstances = [];

  // This keeps the beforeUpdate handler from going into a loop when we're taming Font Awesome's magic.
  let _updatingIcon = false;
  // Save the old value of hide and icon, so we can .
  let _oldHide;
  let _oldIcon;

  // Grab styles from the styling object or use the styles provided.
  $: _styles = typeof styling === 'object' ? styling : styleRegistry[styling];
  // Grab the icons from the icons object or use provided icons
  $: _icons = typeof icons === 'object' ? icons : iconRegistry[icons];
  $: _widthStyle = typeof width === 'string' ? 'width: ' + width + ';' : '';
  $: _minHeightStyle = typeof minHeight === 'string' ? 'min-height: ' + minHeight + ';' : '';

  export const getState = () => _state;
  export const getStyle = name => (_styles && name in _styles) ? _styles[name] : styling + '-' + name;
  export const getIcon = name => (_icons && name in _icons) ? _icons[name] : icons + '-icon-' + name;

  beforeUpdate(async () => {
    if (_updatingIcon) {
      return;
    }

    runModules('update');

    // Update the timed hiding.
    if (hide !== _oldHide) {
      if (!hide) {
        cancelClose();
      } else if (!_oldHide) {
        queueClose();
      }
    }
    queuePosition();

    // Font Awesome 5 uses dark magic by replacing the icon element with an SVG.
    // In order to make it play nice with Svelte, we have to clear the element
    // and make it again.
    if (
      icon !== _oldIcon &&
      (
        (icon === true && icons === 'fontawesome5') ||
        (typeof icon === 'string' && icon.match(/(^| )fa[srlb]($| )/))
      )
    ) {
      const newIcon = icon;
      icon = false;
      _updatingIcon = true;
      await tick();
      icon = newIcon;
      _updatingIcon = false;
    }

    // Save old options.
    _oldHide = hide;
    _oldIcon = icon;
  });

  function mouseenter (e) {
    // Stop animation, reset the removal timer when the user mouses over.
    if (mouseReset && _animating === 'out') {
      if (!_timerHide) {
        return;
      }
      cancelClose();
    }
    // Stop the close timer.
    if (hide && mouseReset) {
      cancelClose();
    }

    dispatch('mouseenter', e);
  }

  function mouseleave (e) {
    // Start the close timer.
    if (hide && mouseReset && _animating !== 'out') {
      queueClose();
    }
    positionAll();

    dispatch('mouseleave', e);
  }

  export async function init (notice) {
    // Init is passed the instance, since Svelte does not give access to it.
    self = notice;

    // Add the notice to the notice array.
    if (stack && stack.push === 'top') {
      notices.splice(0, 0, self);
    } else {
      notices.push(self);
    }

    // Wait for self to propagate to modules.
    await tick();

    runModules('init');

    // We're now initialized, but haven't been opened yet.
    _state = 'closed';

    // Display the notice.
    if (autoDisplay) {
      open();
    }
  }

  // This runs an event on all the modules.
  function runModules (event) {
    if (event === 'init') {
      // Initializing a module should only be done if it has an init
      // function, which means it's not rendered in the template.
      for (let key in _moduleAccessors) {
        if (!_moduleAccessors.hasOwnProperty(key)) {
          continue;
        }
        initModule(key, _moduleAccessors[key]);
      }
      for (let key in moduleRegistry) {
        if (!moduleRegistry.hasOwnProperty(key)) {
          continue;
        }
        if ('factory' in moduleRegistry[key]) {
          const moduleOptions = Object.assign({
            '_notice': self
          }, modules[key]);
          _moduleAccessors[key] = moduleRegistry[key].factory(self, moduleOptions);
          initModule(key, _moduleAccessors[key]);
        }
      }
    } else {
      for (let key in _moduleAccessors) {
        if (!_moduleAccessors.hasOwnProperty(key)) {
          continue;
        }
        if (event === 'update') {
          if ('$set' in _moduleAccessors[key]) {
            const moduleOptions = Object.assign({
              '_notice': self
            }, modules[key]);
            _moduleAccessors[key].$set(moduleOptions);
          }
        } else {
          if (event in _moduleAccessors[key]) {
            _moduleAccessors[key][event]();
          }
        }
      }
    }
  }

  function saveAccessor (key, accessor) {
    _moduleAccessors[key] = accessor;
  }

  // This passes module options to a module.
  function initModule (key, accessor) {
    if (!modules.hasOwnProperty(key)) {
      modules[key] = {};
    }
    if ('$set' in accessor) {
      const moduleOptions = Object.assign({
        '_notice': self
      }, modules[key]);
      accessor.$set(moduleOptions);
    }
    if ('init' in accessor) {
      accessor.init();
    }
  }

  // Display the notice.
  export let open = () => {
    if (_state === 'opening') {
      return;
    }
    if (_state === 'open') {
      if (hide) {
        queueClose();
      }
      return;
    }
    _state = 'opening';
    // This makes the notice visibity: hidden; so its dimensions can be
    // determined.
    _animatingClass = 'ui-pnotify-initial-hidden';
    runModules('beforeOpen');

    const afterOpenCallback = () => {
      // Now set it to hide.
      if (hide) {
        queueClose();
      }

      _state = 'open';

      runModules('afterOpen');
    };

    if (_moduleIsNoticeOpen) {
      afterOpenCallback();
      return;
    }

    // If the notice is not in the DOM, or in the wrong context, append it.
    if (
      refs.elem &&
      !refs.elem.parentNode ||
      (
        stack &&
        stack.context &&
        stack.context !== refs.elem.parentNode
      )
    ) {
      if (stack && stack.context) {
        stack.context.appendChild(refs.elem);
      } else if (document.body) {
        document.body.appendChild(refs.elem);
      } else {
        throw new Error('No context to open this notice in.');
      }
    }

    // Wait until the DOM is updated.
    setTimeout(() => {
      if (stack) {
        // Mark the stack so it won't animate the new notice.
        stack.animation = false;
        // Now position all the notices.
        positionAll();
        // Reset animation.
        stack.animation = true;
      }

      animateIn(afterOpenCallback);
    }, 0);
  };

  // Remove the notice.
  export let close = timerHide => {
    if (_state === 'closing' || _state === 'closed') {
      return;
    }
    _state = 'closing';
    _timerHide = !!timerHide; // Make sure it's a boolean.
    runModules('beforeClose');

    if (_timer && clearTimeout) {
      clearTimeout(_timer);
      _timer = null;
    }
    animateOut(() => {
      _state = 'closed';
      runModules('afterClose');
      queuePosition();
      if (destroy) {
        // If we're supposed to destroy the notice, run the destroy module
        // events, remove from notices array, and let Svelte handle DOM removal.
        runModules('beforeDestroy');
        if (notices !== null) {
          const idx = notices.indexOf(self);
          if (idx !== -1) {
            notices.splice(idx, 1);
          }
        }
        self.$destroy();
        runModules('afterDestroy');
        runModules('$destroy');
      } else if (remove) {
        // If we're supposed to remove the notice from the DOM, do it.
        refs.elem && refs.elem.parentNode.removeChild(refs.elem);
      }
    });
  };

  // Animate the notice in.
  export let animateIn = async callback => {
    // Declare that the notice is animating in.
    _animating = 'in';
    const finished = event => {
      if (event && refs.elem && event.target !== refs.elem) {
        return;
      }
      refs.elem && refs.elem.removeEventListener('transitionend', finished);
      if (_animTimer) {
        clearTimeout(_animTimer);
      }
      if (_animating !== 'in') {
        return;
      }
      let visible = _moduleIsNoticeOpen;
      if (!visible && refs.elem) {
        const domRect = refs.elem.getBoundingClientRect();
        for (let prop in domRect) {
          if (domRect[prop] > 0) {
            visible = true;
            break;
          }
        }
      }
      if (visible) {
        if (callback) {
          callback.call();
        }
        // Declare that the notice has completed animating.
        _animating = false;
      } else {
        _animTimer = setTimeout(finished, 40);
      }
    };

    if (animation === 'fade') {
      refs.elem && refs.elem.addEventListener('transitionend', finished);
      _animatingClass = 'ui-pnotify-in';
      // eslint-disable-next-line no-unused-expressions
      refs.elem && refs.elem.style.opacity; // This line is necessary for some reason. Some notices don't fade without it.
      _animatingClass = 'ui-pnotify-in ui-pnotify-fade-in';
      // Just in case the event doesn't fire, call it after 650 ms.
      _animTimer = setTimeout(finished, 650);
    } else {
      _animatingClass = 'ui-pnotify-in';
      await tick();
      finished();
    }
  };

  // Animate the notice out.
  export let animateOut = async callback => {
    // Declare that the notice is animating out.
    _animating = 'out';
    const finished = event => {
      if (event && refs.elem && event.target !== refs.elem) {
        return;
      }
      refs.elem && refs.elem.removeEventListener('transitionend', finished);
      if (_animTimer) {
        clearTimeout(_animTimer);
      }
      if (_animating !== 'out') {
        return;
      }
      let visible = _moduleIsNoticeOpen;
      if (!visible && refs.elem) {
        const domRect = refs.elem.getBoundingClientRect();
        for (let prop in domRect) {
          if (domRect[prop] > 0) {
            visible = true;
            break;
          }
        }
      }
      if (!refs.elem || !refs.elem.style.opacity || refs.elem.style.opacity === '0' || !visible) {
        _animatingClass = '';
        if (stack && stack.overlay) {
          // Go through the modal stack to see if any are left open.
          // TODO: Rewrite this cause it sucks.
          let stillOpen = false;
          for (let i = 0; i < notices.length; i++) {
            const notice = notices[i];
            if (notice !== self && notice.stack === stack && notice.getState() !== 'closed') {
              stillOpen = true;
              break;
            }
          }
          if (!stillOpen) {
            removeStackOverlay(stack);
          }
        }
        if (callback) {
          callback.call();
        }
        // Declare that the notice has completed animating.
        _animating = false;
      } else {
        // In case this was called before the notice finished animating.
        _animTimer = setTimeout(finished, 40);
      }
    };

    if (animation === 'fade') {
      refs.elem && refs.elem.addEventListener('transitionend', finished);
      _animatingClass = 'ui-pnotify-in';
      // Just in case the event doesn't fire, call it after 650 ms.
      _animTimer = setTimeout(finished, 650);
    } else {
      _animatingClass = '';
      await tick();
      finished();
    }
  };

  // Position the notice.
  export function position () {
    // Get the notice's stack.
    let elem = refs.elem;
    if (!stack || !elem) {
      return;
    }
    if (!stack.context) {
      stack.context = document.body;
    }
    if (typeof stack.nextpos1 !== 'number') {
      stack.nextpos1 = stack.firstpos1;
    }
    if (typeof stack.nextpos2 !== 'number') {
      stack.nextpos2 = stack.firstpos2;
    }
    if (typeof stack.addpos2 !== 'number') {
      stack.addpos2 = 0;
    }

    // Skip this notice if it's not shown.
    if (
      !elem.classList.contains('ui-pnotify-in') &&
      !elem.classList.contains('ui-pnotify-initial-hidden')
    ) {
      return;
    }

    if (stack.modal) {
      if (!stack.overlay) {
        createStackOverlay(stack);
      }
      insertStackOverlay(stack);
    }

    // Read from the DOM to cause refresh.
    elem.getBoundingClientRect();

    if (stack.animation) {
      // Add animate class.
      _moveClass = 'ui-pnotify-move';
    }

    let spaceY = (stack.context === document.body ? window.innerHeight : stack.context.scrollHeight);
    let spaceX = (stack.context === document.body ? window.innerWidth : stack.context.scrollWidth);

    let csspos1;

    if (stack.dir1) {
      csspos1 = {
        'down': 'top',
        'up': 'bottom',
        'left': 'right',
        'right': 'left'
      }[stack.dir1];

      // Calculate the current pos1 value.
      let curpos1;
      switch (stack.dir1) {
        case 'down':
          curpos1 = elem.offsetTop;
          break;
        case 'up':
          curpos1 = spaceY - elem.scrollHeight - elem.offsetTop;
          break;
        case 'left':
          curpos1 = spaceX - elem.scrollWidth - elem.offsetLeft;
          break;
        case 'right':
          curpos1 = elem.offsetLeft;
          break;
      }
      // Remember the first pos1, so the first notice goes there.
      if (typeof stack.firstpos1 === 'undefined') {
        stack.firstpos1 = curpos1;
        stack.nextpos1 = stack.firstpos1;
      }
    }

    if (stack.dir1 && stack.dir2) {
      let csspos2 = {
        'down': 'top',
        'up': 'bottom',
        'left': 'right',
        'right': 'left'
      }[stack.dir2];

      // Calculate the current pos2 value.
      let curpos2;
      switch (stack.dir2) {
        case 'down':
          curpos2 = elem.offsetTop;
          break;
        case 'up':
          curpos2 = spaceY - elem.scrollHeight - elem.offsetTop;
          break;
        case 'left':
          curpos2 = spaceX - elem.scrollWidth - elem.offsetLeft;
          break;
        case 'right':
          curpos2 = elem.offsetLeft;
          break;
      }
      // Remember the first pos2, so the first notice goes there.
      if (typeof stack.firstpos2 === 'undefined') {
        stack.firstpos2 = curpos2;
        stack.nextpos2 = stack.firstpos2;
      }

      // Check that it's not beyond the viewport edge.
      const endY = stack.nextpos1 + elem.offsetHeight + (typeof stack.spacing1 === 'undefined' ? 25 : stack.spacing1);
      const endX = stack.nextpos1 + elem.offsetWidth + (typeof stack.spacing1 === 'undefined' ? 25 : stack.spacing1);
      if (
        ((stack.dir1 === 'down' || stack.dir1 === 'up') && endY > spaceY) ||
        ((stack.dir1 === 'left' || stack.dir1 === 'right') && endX > spaceX)
      ) {
        // If it is, it needs to go back to the first pos1, and over on pos2.
        stack.nextpos1 = stack.firstpos1;
        stack.nextpos2 += stack.addpos2 + (typeof stack.spacing2 === 'undefined' ? 25 : stack.spacing2);
        stack.addpos2 = 0;
      }

      // Move the notice on dir2.
      if (typeof stack.nextpos2 === 'number') {
        elem.style[csspos2] = stack.nextpos2 + 'px';
        if (!stack.animation) {
          // eslint-disable-next-line no-unused-expressions
          elem.style[csspos2]; // Read from the DOM for update.
        }
      }

      // Keep track of the widest/tallest notice in the column/row, so we can push the next column/row.
      switch (stack.dir2) {
        case 'down':
        case 'up':
          if (elem.offsetHeight + (parseFloat(elem.style.marginTop, 10) || 0) + (parseFloat(elem.style.marginBottom, 10) || 0) > stack.addpos2) {
            stack.addpos2 = elem.offsetHeight;
          }
          break;
        case 'left':
        case 'right':
          if (elem.offsetWidth + (parseFloat(elem.style.marginLeft, 10) || 0) + (parseFloat(elem.style.marginRight, 10) || 0) > stack.addpos2) {
            stack.addpos2 = elem.offsetWidth;
          }
          break;
      }
    } else if (stack.dir1) {
      // Center the notice along dir1 axis, because the stack has no dir2.
      let cssMiddle, cssposCross;
      switch (stack.dir1) {
        case 'down':
        case 'up':
          cssposCross = ['left', 'right'];
          cssMiddle = (stack.context.scrollWidth / 2) - (elem.offsetWidth / 2);
          break;
        case 'left':
        case 'right':
          cssposCross = ['top', 'bottom'];
          cssMiddle = (spaceY / 2) - (elem.offsetHeight / 2);
          break;
      }
      elem.style[cssposCross[0]] = cssMiddle + 'px';
      elem.style[cssposCross[1]] = 'auto';
      if (!stack.animation) {
        // eslint-disable-next-line no-unused-expressions
        elem.style[cssposCross[0]]; // Read from the DOM for update.
      }
    }

    if (stack.dir1) {
      // Move the notice on dir1.
      if (typeof stack.nextpos1 === 'number') {
        elem.style[csspos1] = stack.nextpos1 + 'px';
        if (!stack.animation) {
          // eslint-disable-next-line no-unused-expressions
          elem.style[csspos1]; // Read from the DOM for update.
        }
      }

      // Calculate the next dir1 position.
      switch (stack.dir1) {
        case 'down':
        case 'up':
          stack.nextpos1 += elem.offsetHeight + (typeof stack.spacing1 === 'undefined' ? 25 : stack.spacing1);
          break;
        case 'left':
        case 'right':
          stack.nextpos1 += elem.offsetWidth + (typeof stack.spacing1 === 'undefined' ? 25 : stack.spacing1);
          break;
      }
    } else {
      // Center the notice on the screen, because the stack has no dir1.
      let cssMiddleLeft = (spaceX / 2) - (elem.offsetWidth / 2);
      let cssMiddleTop = (spaceY / 2) - (elem.offsetHeight / 2);
      elem.style.left = cssMiddleLeft + 'px';
      elem.style.top = cssMiddleTop + 'px';
      if (!stack.animation) {
        // eslint-disable-next-line no-unused-expressions
        elem.style.left; // Read from the DOM for update.
      }
    }
  }

  // Queue the position all function so it doesn't run repeatedly and
  // use up resources.
  export function queuePosition (milliseconds) {
    if (posTimer) {
      clearTimeout(posTimer);
    }
    if (!milliseconds) {
      milliseconds = 10;
    }
    posTimer = setTimeout(() => {
      positionAll();
    }, milliseconds);
  }

  // Cancel any pending removal timer.
  export function cancelClose () {
    if (_timer) {
      clearTimeout(_timer);
    }
    if (_animTimer) {
      clearTimeout(_animTimer);
    }
    if (_state === 'closing') {
      // If it's animating out, stop it.
      _state = 'open';
      _animating = false;
      _animatingClass = animation === 'fade' ? 'ui-pnotify-in ui-pnotify-fade-in' : 'ui-pnotify-in';
    }
  }

  // Queue a close timer.
  export function queueClose () {
    // Cancel any current close timer.
    cancelClose();
    _timer = setTimeout(() => close(true), (isNaN(delay) ? 0 : delay));
  }

  export function fire (name, detail) {
    dispatch(name, detail);
  }

  export function addModuleClass (element, ...classNames) {
    for (let i = 0; i < classNames.length; i++) {
      let className = classNames[i];
      if (_moduleClasses[element].indexOf(className) === -1) {
        _moduleClasses[element].push(className);
      }
    }
    _moduleClasses[element] = _moduleClasses[element];
  }

  export function removeModuleClass (element, ...classNames) {
    for (let i = 0; i < classNames.length; i++) {
      let className = classNames[i];
      const idx = _moduleClasses[element].indexOf(className);
      if (idx !== -1) {
        _moduleClasses[element].splice(idx, 1);
      }
    }
    _moduleClasses[element] = _moduleClasses[element];
  }

  export function hasModuleClass (element, ...classNames) {
    for (let i = 0; i < classNames.length; i++) {
      let className = classNames[i];
      if (_moduleClasses[element].indexOf(className) === -1) {
        return false;
      }
    }
    return true;
  }

  export function getModuleAccessors () {
    return _moduleAccessors;
  }

  export function getModuleIsNoticeOpen () {
    return _moduleIsNoticeOpen;
  }

  export function setModuleIsNoticeOpen (value) {
    return _moduleIsNoticeOpen = value;
  }

  export function setAnimating (value) {
    return _animating = value;
  }

  export function getAnimatingClass () {
    return _animatingClass;
  }

  export function setAnimatingClass (value) {
    return _animatingClass = value;
  }
</script>

<style>
  /* -- Notice */
  :global(body > .ui-pnotify) {
    /* Notices in the body context should be fixed to the viewport. */
    position: fixed;
    /* Ensures notices are above everything */
    z-index: 100040;
  }
  :global(body > .ui-pnotify.ui-pnotify-modal) {
    z-index: 100042;
  }
  :global(.ui-pnotify) {
    position: absolute;
    height: auto;
    z-index: 1;
    display: none;
  }
  :global(.ui-pnotify.ui-pnotify-modal) {
    z-index: 3;
  }
  :global(.ui-pnotify.ui-pnotify-in) {
    display: block;
  }
  :global(.ui-pnotify.ui-pnotify-initial-hidden) {
    display: block;
    visibility: hidden;
  }
  :global(.ui-pnotify.ui-pnotify-move) {
    transition: left .5s ease, top .5s ease, right .5s ease, bottom .5s ease;
  }
  :global(.ui-pnotify.ui-pnotify-fade-slow) {
    transition: opacity .4s linear;
    opacity: 0;
  }
  :global(.ui-pnotify.ui-pnotify-fade-slow.ui-pnotify.ui-pnotify-move) {
    transition: opacity .4s linear, left .5s ease, top .5s ease, right .5s ease, bottom .5s ease;
  }
  :global(.ui-pnotify.ui-pnotify-fade-normal) {
    transition: opacity .25s linear;
    opacity: 0;
  }
  :global(.ui-pnotify.ui-pnotify-fade-normal.ui-pnotify.ui-pnotify-move) {
    transition: opacity .25s linear, left .5s ease, top .5s ease, right .5s ease, bottom .5s ease;
  }
  :global(.ui-pnotify.ui-pnotify-fade-fast) {
    transition: opacity .1s linear;
    opacity: 0;
  }
  :global(.ui-pnotify.ui-pnotify-fade-fast.ui-pnotify.ui-pnotify-move) {
    transition: opacity .1s linear, left .5s ease, top .5s ease, right .5s ease, bottom .5s ease;
  }
  :global(.ui-pnotify.ui-pnotify-fade-in) {
    opacity: 1;
  }
  :global(.ui-pnotify .ui-pnotify-shadow) {
    -webkit-box-shadow: 0px 6px 28px 0px rgba(0,0,0,0.1);
    -moz-box-shadow: 0px 6px 28px 0px rgba(0,0,0,0.1);
    box-shadow: 0px 6px 28px 0px rgba(0,0,0,0.1);
  }
  :global(.ui-pnotify-container) {
    background-position: 0 0;
    padding: .8em;
    height: 100%;
    margin: 0;
  }
  :global(.ui-pnotify-container:after) {
    content: " "; /* Older browser do not support empty content */
    visibility: hidden;
    display: block;
    height: 0;
    clear: both;
  }
  :global(.ui-pnotify-container.ui-pnotify-sharp) {
    -webkit-border-radius: 0;
    -moz-border-radius: 0;
    border-radius: 0;
  }
  :global(.ui-pnotify-title) {
    display: block;
    white-space: pre-line;
    margin-bottom: .4em;
    margin-top: 0;
  }
  :global(.ui-pnotify.ui-pnotify-with-icon .ui-pnotify-title),
  :global(.ui-pnotify.ui-pnotify-with-icon .ui-pnotify-text) {
    margin-left: 24px;
  }
  :global([dir=rtl] .ui-pnotify.ui-pnotify-with-icon .ui-pnotify-title),
  :global([dir=rtl] .ui-pnotify.ui-pnotify-with-icon .ui-pnotify-text) {
    margin-right: 24px;
    margin-left: 0;
  }
  /* Bootstrap 4: make title text a tad smaller. */
  :global(.ui-pnotify .bootstrap4-title) {
    font-size: 1.2rem;
  }
  :global(.ui-pnotify-text) {
    display: block;
    white-space: pre-line;
  }
  :global(.ui-pnotify-icon),
  :global(.ui-pnotify-icon span) {
    display: block;
    float: left;
  }
  :global([dir=rtl] .ui-pnotify-icon),
  :global([dir=rtl] .ui-pnotify-icon span) {
    float: right;
  }
  /* Bootstrap 3: correct positioning of icon. */
  :global(.ui-pnotify .bootstrap3-icon > span) {
    position: relative;
    top: 2px;
  }
  /* Bootstrap 4: correct positioning of icon. */
  :global(.ui-pnotify .bootstrap4-icon > span) {
    position: relative;
    top: 4px;
  }
  /* Overlay */
  :global(.ui-pnotify-modal-overlay) {
    background-color: rgba(0, 0, 0, .4);
    top: 0;
    left: 0;
    position: absolute;
    height: 100%;
    width: 100%;
    z-index: 2;
  }
  :global(body > .ui-pnotify-modal-overlay) {
    position: fixed;
    z-index: 100041;
  }
</style>
